PLC Project (1): Library
========================

    Project root: /home/travis/build/pcdshub/lcls2-cc-lib/lcls2-cc-lib
    Project path: Library/Library.plcproj
    TMC path:     Library/Library.tmc
    AMS ID:       
    IP Address:    (* based on AMS ID)
    Port:         851

    Source files:
        1.) Library/Devices/PPM/ENUM_PPM_States.TcDUT
        2.) Library/Devices/PPM/FB_PPM.TcPOU
        3.) Library/Devices/PPM/FB_PPM_Gige.TcPOU
        4.) Library/Devices/PPM/FB_PPM_PowerMeter.TcPOU
        5.) Library/Devices/PPM/FB_PPM_States.TcPOU
        6.) Library/Devices/REF/FB_REF.TcPOU
        7.) Library/Devices/REF/FB_REF_Laser.TcPOU
        8.) Library/Devices/SLITS/FB_SLITS.TcPOU
        9.) Library/Devices/SLITS/FB_SLITS_POWER.TcPOU
        10.) Library/Devices/XPIM/ENUM_XPIM_Filters.TcDUT
        11.) Library/Devices/XPIM/ENUM_XPIM_States.TcDUT
        12.) Library/Devices/XPIM/FB_XPIM.TcPOU
        13.) Library/Devices/XPIM/FB_XPIM_FilterWheel.TcPOU
        14.) Library/Devices/XPIM/FB_XPIM_Opal.TcPOU
        15.) Library/Devices/XPIM/FB_XPIM_States.TcPOU
        16.) Library/POUs/FB_L2SI_Flowmeter.TcPOU
        17.) Library/POUs/FB_XTES_Flowswitch.TcPOU
        18.) Library/Version/Global_Version.TcGVL

    POUs:
        1.) FB_L2SI_Flowmeter
        2.) FB_PPM
        3.) FB_PPM_Gige
        4.) FB_PPM_PowerMeter
        5.) FB_PPM_States
        6.) FB_REF
        7.) FB_REF_Laser
        8.) FB_SLITS
        9.) FB_SLITS_POWER
        10.) FB_XPIM
        11.) FB_XPIM_FilterWheel
        12.) FB_XPIM_Opal
        13.) FB_XPIM_States
        14.) FB_XTES_Flowswitch

    GVLs:
        1.) Global_Version

DUT: ENUM_PPM_States
--------------------

File: Library/Devices/PPM/ENUM_PPM_States.TcDUT

```vhdl
{attribute 'qualified_only'}
TYPE ENUM_PPM_States :
(
    Unknown := 0,
    OUT := 1,
    PowerMeter := 2,
    PolishedYag := 3,
    FrostedYag := 4
);
END_TYPE
```


DUT: ENUM_XPIM_Filters
----------------------

File: Library/Devices/XPIM/ENUM_XPIM_Filters.TcDUT

```vhdl
{attribute 'qualified_only'}
TYPE ENUM_XPIM_Filters :
(
    Unknown := 0,
    T50 := 1,
    T25 := 2,
    T10 := 3,
    T5 := 4,
    T1 := 5,
    T100 := 6
);
END_TYPE
```


DUT: ENUM_XPIM_States
---------------------

File: Library/Devices/XPIM/ENUM_XPIM_States.TcDUT

```vhdl
{attribute 'qualified_only'}
TYPE ENUM_XPIM_States :
(
    Unknown := 0,
    OUT := 1,
    Yag := 2,
    Diamond := 3,
    Reticle := 4
);
END_TYPE
```


GVL: Global_Version
-------------------

File: Library/Version/Global_Version.TcGVL

```vhdl
{attribute 'TcGenerated'}
{attribute 'no-analysis'}
// This function has been automatically generated from the project information.
VAR_GLOBAL CONSTANT
    {attribute 'const_non_replaced'}
    {attribute 'linkalways'}
    stLibVersion_lcls2_cc_lib : ST_LibVersion := (iMajor := 0, iMinor := 0, iBuild := 0, iRevision := 0, sVersion := '0.0.0');
END_VAR
```


POU: FB_L2SI_Flowmeter
----------------------

File: Library/POUs/FB_L2SI_Flowmeter.TcPOU

```vhdl
FUNCTION_BLOCK FB_L2SI_Flowmeter
VAR
    {attribute 'pytmc' := '
        pv: MA
        io: input
    '}
    fRaw AT %I*: INT;

    {attribute 'pytmc' := '
        pv: FLOW
        io: input
    '}
    fFlowRate: LREAL;
END_VAR


END_FUNCTION_BLOCK
```


POU: FB_PPM
-----------

File: Library/Devices/PPM/FB_PPM.TcPOU

```vhdl
FUNCTION_BLOCK FB_PPM
VAR_IN_OUT
    stYStage: DUT_MotionStage;
END_VAR
VAR_INPUT
    fOut: LREAL;
    fPower: LREAL;
    fPolished: LREAL;
    fFrosted: LREAL;
END_VAR
VAR
    fbYStage: FB_MotionStage;

    {attribute 'pytmc' := '
        pv: MMS:STATE
        io: i
    '}
    fbStates: FB_PPM_States;

    {attribute 'pytmc' := '
        pv: SPM
    '}
    fbPowerMeter: FB_PPM_PowerMeter;

    {attribute 'pytmc' := '
        pv: CAM
    '}
    fbGige: FB_PPM_Gige;

    {attribute 'pytmc' :='
        pv: SFM
    '}
    fbFlowMeter: FB_L2SI_Flowmeter;

    {attribute 'pytmc' := '
        pv: YAG
        io: input
    '}
    fbYagThermoCouple: FB_ThermoCouple;
END_VAR
fbYStage(stMotionStage:=stYStage);
fbStates(
    stMotionStage:=stYStage,
    bEnable := TRUE,
    fOut:=fOut,
    fPower:=fPower,
    fPolished:=fPolished,
    fFrosted:=fFrosted);
stYStage.bHardwareEnable := TRUE;
stYStage.bPowerSelf := TRUE;
stYStage.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
fbPowerMeter();
fbGige();
fbFlowMeter();
fbYagThermoCouple();

END_FUNCTION_BLOCK
```


POU: FB_PPM_Gige
----------------

File: Library/Devices/PPM/FB_PPM_Gige.TcPOU

```vhdl
FUNCTION_BLOCK FB_PPM_Gige
VAR
    iIlluminatorINT AT %Q*: INT;

    {attribute 'pytmc' := '
        pv: PWR
        ZNAM: OFF
        ONAM: ON
    '}
    bGigePower AT %Q*: BOOL;

    {attribute 'pytmc' := '
        pv: CIL:PCT
        EGU: %
    '}
    fIlluminatorPercent: LREAL;

    fbGetIllPercent: FB_AnalogInput;
    fbSetIllPercent: FB_AnalogOutput;

    bGigeInit: BOOL := FALSE;
END_VAR
// Turn the GigE on by default
IF NOT bGigeInit THEN
    bGigePower := TRUE;
    bGigeInit := TRUE;
END_IF

// Illuminator conversion to percentage
fbSetIllPercent(
    fReal:=fIlluminatorPercent,
    fSafeMax:=100,
    fSafeMin:=0,
    iTermBits:=15,
    fTermMax:=100,
    fTermMin:=0,
    iRaw=>iIlluminatorINT);
fbGetIllPercent(
    iRaw:=iIlluminatorINT,
    iTermBits:=15,
    fTermMax:=100,
    fTermMin:=0,
    fReal=>fIlluminatorPercent);

END_FUNCTION_BLOCK
```


POU: FB_PPM_PowerMeter
----------------------

File: Library/Devices/PPM/FB_PPM_PowerMeter.TcPOU

```vhdl
FUNCTION_BLOCK FB_PPM_PowerMeter
VAR
    iVoltageINT AT %I*: INT;

    {attribute 'pytmc' := '
        pv: VOLT
        io: input
        field: EGU mV
    '}
    fVoltage: LREAL;

    {attribute 'pytmc' := '
        pv: VOLT_BUFFER
        io: input
        field: EGU mV
    '}
    fVoltageBuffer: ARRAY[1..1000] OF LREAL;

    {attribute 'pytmc' := '
        pv: CALIB
        io: input
    '}
    fCalibBase: LREAL;

    {attribute 'pytmc' := '
        pv: CALIB_BUFFER
        io: input
    '}
    fCalibBaseBuffer: ARRAY[1..1000] OF LREAL;

    {attribute 'pytmc' := '
        pv: MJ
        io: input
        field: EGU mJ
    '}
    fCalibMJ: LREAL;

    {attribute 'pytmc' := '
        pv: MJ_BUFFER
        io: input
        field: EGU mJ
    '}
    fCalibMJBuffer: ARRAY[1..1000] OF LREAL;

    {attribute 'pytmc' := '
        pv:
        io: input
    '}
    fbThermoCouple: FB_ThermoCouple;

    {attribute 'pytmc' := '
        pv: CALIB:OFFSET
        io: io
    '}
    fCalibRelOffset: LREAL;

    {attribute 'pytmc' := '
        pv: CALIB:RATIO
        io: io
    '}
    fCalibRelRatio: LREAL;

    {attribute 'pytmc' := '
        pv: CALIB:MJ_RATIO
        io: io
    '}
    fCalibMJRatio: LREAL;

    fbGetPMVoltage: FB_AnalogInput;
    fbVoltageBuffer: FB_LREALBuffer;
    fbCalibBaseBuffer: FB_LREALBuffer;
    fbCalibMJBuffer: FB_LREALBuffer;
END_VAR
fbThermoCouple();

// Convert the terminal's integer into a value in millivolts
fbGetPMVoltage(
    iRaw := iVoltageINT,
    iTermBits := 15,
    fTermMax := 10000,
    fTermMin := 0,
    fReal => fVoltage);

// Power meter calibration
fCalibBase := (fVoltage + fCalibRelOffset) * fCalibRelRatio;
fCalibMJ := fCalibBase * fCalibMJRatio;

// Buffer the full-rate Voltage and calibrated MJ values
fbVoltageBuffer(
    bExecute := TRUE,
    fInput := fVoltage,
    arrOutput => fVoltageBuffer);
fbCalibBaseBuffer(
    bExecute := TRUE,
    fInput := fCalibBase,
    arrOutput => fCalibBaseBuffer);
fbCalibMJBuffer(
    bExecute := TRUE,
    fInput := fCalibMJ,
    arrOutput => fCalibMJBuffer);

END_FUNCTION_BLOCK
```


POU: FB_PPM_States
------------------

File: Library/Devices/PPM/FB_PPM_States.TcPOU

```vhdl
FUNCTION_BLOCK FB_PPM_States
VAR_IN_OUT
    stMotionStage: DUT_MotionStage;
END_VAR
VAR_INPUT
    bEnable: BOOL;
    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    enumSet: ENUM_PPM_states;
    bStatesLock: BOOL;
    fOut: LREAL;
    fPower: LREAL;
    fPolished: LREAL;
    fFrosted: LREAL;
END_VAR
VAR_OUTPUT
    bError: BOOL;
    sErrorMessage: STRING;
    bBusy: BOOL;
    bDone: BOOL;
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    enumGet: ENUM_PPM_States;
END_VAR
VAR
    bInit: BOOL;
    arrStates: ARRAY[1..15] OF DUT_PositionState;
    nIter: INT;

    {attribute 'pytmc' := '
        pv:
        io: io
    '}
    fbStateManager: FB_PositionStateManager;

    fbLockOut: FB_PositionStateLock;
    fbLockPowerMeter: FB_PositionStateLock;
    fbLockPolishedYag: FB_PositionStateLock;
    fbLockFrostedYag: FB_PositionStateLock;
END_VAR
VAR CONSTANT
    fInDelta: LREAL := 0.1;
    fOutDelta: LREAL := 10;
    fInVelocity: LREAL := 80;
    fOutVelocity: LREAL := 65;
    fAccel: LREAL := 200;
    fOutDecel: LREAL := 25;
END_VAR
IF NOT bInit THEN
    bInit := FALSE;
    FOR nIter := 1 TO 4 DO
        arrStates[nIter].fDelta := fInDelta;
        arrStates[nIter].fVelocity := fInVelocity;
        arrStates[nIter].fAccel := fAccel;
        arrStates[nIter].fDecel := fAccel;
        arrStates[nIter].bLocked := bStatesLock;
        arrStates[nIter].bValid := TRUE;
        // TODO implement PMPS instead of doing this
        arrStates[nIter].bMoveOk := TRUE;
    END_FOR
    arrStates[1].sName := 'Out';
    arrStates[1].fPosition := fOut;
    arrStates[1].fDelta := fOutDelta;
    arrStates[1].fVelocity := fOutVelocity;
    arrStates[1].fDecel := fOutDecel;
    arrStates[2].sName := 'PowerMeter';
    arrStates[2].fPosition := fPower;
    arrStates[3].sName := 'PolishedYag';
    arrStates[3].fPosition := fPolished;
    arrStates[4].sName := 'FrostedYag';
    arrStates[4].fPosition := fFrosted;
END_IF

fbLockOut(stPositionState := arrStates[1]);
fbLockPowerMeter(stPositionState := arrStates[2]);
fbLockPolishedYag(stPositionState := arrStates[3]);
fbLockFrostedYag(stPositionState := arrStates[4]);

fbStateManager(
    stMotionStage := stMotionStage,
    arrStates := arrStates,
    setState := enumSet,
    bEnable := bEnable,
    bError => bError,
    sErrorMessage => sErrorMessage,
    bBusy => bBusy,
    bDone => bDone,
    getState => enumGet);

END_FUNCTION_BLOCK
```


POU: FB_REF
-----------

File: Library/Devices/REF/FB_REF.TcPOU

```vhdl
FUNCTION_BLOCK FB_REF
VAR_IN_OUT
    stYStage: DUT_MotionStage;
END_VAR
VAR_INPUT
    fIn: LREAL;
    fOut: LREAL;
END_VAR
VAR
    fbYStage: FB_MotionStage;
    {attribute 'pytmc' := '
        pv: MMS:STATE
        io: io
    '}
    fbStates: FB_EpicsInOut;

    {attribute 'pytmc' := '
        pv: LAS
        io: io
    '}
    fbLaser: FB_REF_Laser;

    bInit: BOOL;
    stOut: DUT_PositionState;
    stIn: DUT_PositionState;
END_VAR
VAR CONSTANT
    bStatesLock: BOOL := FALSE;
    fVelo: LREAL := 65;
    fAccel: LREAL := 25;
END_VAR
IF NOT bInit THEN
    bInit := TRUE;
    stOut.fPosition := fOut;
    stOut.fDelta := 10;
    stOut.fVelocity := fVelo;
    stOut.fAccel := fAccel;
    stOut.fDecel := fAccel;
    stOut.bLocked := bStatesLock;
    stOut.bValid := TRUE;
    stOut.bMoveOk := TRUE;

    stIn.fPosition := fIn;
    stIn.fDelta := 0.1;
    stIn.fVelocity := fVelo;
    stIn.fAccel := fAccel;
    stIn.fDecel := fAccel;
    stIn.bLocked := bStatesLock;
    stIn.bValid := TRUE;
    stIn.bMoveOk := TRUE;
END_IF

fbYStage(stMotionStage:=stYStage);
fbStates(
    stMotionStage:=stYStage,
    stOut := stOut,
    stIn := stIn);
stYStage.bHardwareEnable := TRUE;
stYStage.bPowerSelf := TRUE;
stYStage.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
fbLaser();

END_FUNCTION_BLOCK
```


POU: FB_REF_Laser
-----------------

File: Library/Devices/REF/FB_REF_Laser.TcPOU

```vhdl
FUNCTION_BLOCK FB_REF_Laser
VAR_INPUT
    bShutdown: BOOL;

    {attribute 'pytmc' := '
        pv: PCT
        io: io
    '}
    fLaserPercent: LREAL;
END_VAR
VAR
    iShutdownINT AT %Q*: INT;
    iLaserINT AT %Q*: INT;

    fbGetLasPercent: FB_AnalogInput;
    fbSetLasPercent: FB_AnalogOutput;
END_VAR
// Send 5V to suppress laser
IF bShutdown THEN
    iShutdownINT := LREAL_TO_INT(EXPT(2, 14));
ELSE
    iShutdownINT := 0;
END_IF

// Limit to 0-5V instead of 10V
fbSetLasPercent(
    fReal:=fLaserPercent,
    fSafeMax:=100,
    fSafeMin:=0,
    iTermBits:=15,
    fTermMax:=200,
    fTermMin:=0,
    iRaw=>iLaserInt);
fbGetLasPercent(
    iRaw:=iLaserInt,
    iTermBits:=15,
    fTermMax:=200,
    fTermMin:=0,
    fReal=>fLaserPercent);

END_FUNCTION_BLOCK
```


POU: FB_SLITS
-------------

File: Library/Devices/SLITS/FB_SLITS.TcPOU

```vhdl
FUNCTION_BLOCK FB_SLITS


END_FUNCTION_BLOCK
ACTION ACT_BLOCK:

END_ACTION
ACTION ACT_CalculatePositions:

END_ACTION
```


POU: FB_SLITS_POWER
-------------------

File: Library/Devices/SLITS/FB_SLITS_POWER.TcPOU

```vhdl
FUNCTION_BLOCK FB_SLITS_POWER EXTENDS FB_SLITS
VAR_IN_OUT
    stTopBlade: DUT_MotionStage;
    stBottomBlade: DUT_MotionStage;
    stNorthBlade: DUT_MotionStage;
    stSouthBlade: DUT_MotionStage;
END_VAR
VAR_INPUT
    {attribute 'pytmc' := '
    pv: GO;
    io: io;
    field: ZNAM False
    field: ONAM True
    '}
    bExecuteMotion:BOOL ;
    {attribute 'pytmc' := '
    pv: PMPS_OK;
    io: i;
    field: ZNAM False
    field: ONAM True
    '}
    bMoveOk:BOOL;
END_VAR
VAR_OUTPUT
END_VAR
VAR
    fbTopBlade: FB_MotionStage;
    fbBottomBlade: FB_MotionStage;
    fbNorthBlade: FB_MotionStage;
    fbSouthBlade: FB_MotionStage;
    fPosTopBlade: LREAL;
    fPosBottomBlade: LREAL;
    fPosNorthBlade: LREAL;
    fPosSouthBlade: LREAL;

    (*Motion Parameters*)
    fSmallDelta: LREAL := 0.01;
    fBigDelta: LREAL := 10;
    fMaxVelocity: LREAL := 0.2;
    fHighAccel: LREAL := 0.8;
    fLowAccel: LREAL := 0.1;

    stTop: DUT_PositionState;
    stBOTTOM: DUT_PositionState;
    stNorth: DUT_PositionState;
    stSouth: DUT_PositionState;

    {attribute 'pytmc' := 'pv: TOP'}
    fbTop: FB_StatePTPMove;
    {attribute 'pytmc' := 'pv: BOTTOM'}
    fbBottom: FB_StatePTPMove;
    {attribute 'pytmc' := 'pv: NORTH'}
    fbNorth: FB_StatePTPMove;
    {attribute 'pytmc' := 'pv: SOUTH'}
    fbSouth: FB_StatePTPMove;

    (*EPICS pvs*)
    {attribute 'pytmc' := '
    pv: XWID_REQ;
    io: io;
    '}
    rReqApertureSizeX : REAL;
    {attribute 'pytmc' := '
    pv: YWID_REQ;
    io: io;
    '}
    rReqApertureSizeY : REAL;
    {attribute 'pytmc' := '
    pv: XCEN_REQ;
    io: io;
    '}
    rReqCenterX: REAL;
    {attribute 'pytmc' := '
    pv: YCEN_REQ;
    io: io;
    '}
    rReqCenterY: REAL;

    {attribute 'pytmc' := '
    pv: ACTUAL_XWIDTH;
    io: io;
    '}
    rActApertureSizeX : REAL;

    {attribute 'pytmc' := '
    pv: ACTUAL_YWIDTH;
    io: io;
    '}
    rActApertureSizeY : REAL;
    {attribute 'pytmc' := '
    pv: ACTUAL_XCENTER;
    io: io;
    '}
    rActCenterX: REAL;
    {attribute 'pytmc' := '
    pv: ACTUAL_YCENTER;
    io: io;
    '}
    rActCenterY: REAL;

    {attribute 'pytmc' := '
    pv: XCEN_SETZERO;
    io: io;
    '}
    rSetCenterX: REAL;
    {attribute 'pytmc' := '
    pv: YCEN_SETZERO;
    io: io;
    '}
    rSetCenterY: REAL;


    {attribute 'pytmc' := '
    pv: OPEN;
    io: io;
    field: ZNAM False
    field: ONAM True
    '}
    bOpen: BOOL;

    {attribute 'pytmc' := '
    pv: CLOSE;
    io: io;
    field: ZNAM False
    field: ONAM True
    '}
    bClose: BOOL;

    {attribute 'pytmc' := '
    pv: BLOCK;
    io: io;
    field: ZNAM False
    field: ONAM True
    '}
    bBlock: BOOL;


    {attribute 'pytmc' := '
        pv: FSW
    '}
    fbFlowSwitch: FB_XTES_Flowswitch;


    //RTDs
    {attribute 'pytmc' := '
        pv: TOP:RTD:01
    '}
    RTD_TOP_1: FB_TempSensor;
    {attribute 'pytmc' := '
        pv: TOP:RTD:02
    '}
    RTD_TOP_2: FB_TempSensor;
    {attribute 'pytmc' := '
        pv: BOTTOM:RTD:01
    '}
    RTD_Bottom_1: FB_TempSensor;
    {attribute 'pytmc' := '
        pv: BOTTOM:RTD:02
    '}
    RTD_Bottom_2: FB_TempSensor;

    {attribute 'pytmc' := '
        pv: NORTH:RTD:01
    '}
    RTD_North_1: FB_TempSensor;
    {attribute 'pytmc' := '
        pv: NORTH:RTD:02
    '}
    RTD_North_2: FB_TempSensor;
    {attribute 'pytmc' := '
        pv: SOUTH:RTD:01
    '}
    RTD_South_1: FB_TempSensor;
    {attribute 'pytmc' := '
        pv: SOUTH:RTD:02
    '}
    RTD_South_2: FB_TempSensor;

        //Local variables
    bInit: BOOL :=true;
    rTrig_Block: R_TRIG;
    rTrig_Open: R_TRIG;
    rTrig_Close: R_TRIG;

    fPosBlock: LREAL;
    fPosClose: LREAL;
    fPosOpen: LREAL;


END_VAR
//  init the motion stages parameters
IF ( bInit) THEN
    stTopBlade.bHardwareEnable := TRUE;
    stBottomBlade.bHardwareEnable := TRUE;
    stNorthBlade.bHardwareEnable := TRUE;
    stSouthBlade.bHardwareEnable := TRUE;
    stTopBlade.bPowerSelf :=TRUE;
    stBottomBlade.bPowerSelf :=TRUE;
    stNorthBlade.bPowerSelf :=TRUE;
    stSouthBlade.bPowerSelf :=TRUE;
    stTopBlade.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    stBottomBlade.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    stNorthBlade.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    stSouthBlade.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
END_IF


// Instantiate Function block for all the blades
fbTopBlade(stMotionStage:=stTopBlade);
fbBottomBlade(stMotionStage:=stBottomBlade);
fbNorthBlade(stMotionStage:=stNorthBlade);
fbSouthBlade(stMotionStage:=stSouthBlade);

//SET and GET the requested and Actual values
ACT_CalculatePositions();
//ACT_BLOCK();

// PTP Motion for each blade
stTop.sName := 'Top';
stTop.fPosition := fPosTopBlade;
stTop.fDelta := fSmallDelta;
stTop.fVelocity := fMaxVelocity;
stTop.fAccel := fHighAccel;
stTop.fDecel := fHighAccel;

stBOTTOM.sName := 'Bottom';
stBOTTOM.fPosition := fPosBottomBlade;
stBOTTOM.fDelta := fSmallDelta;
stBOTTOM.fVelocity := fMaxVelocity;
stBOTTOM.fAccel := fHighAccel;
stBOTTOM.fDecel := fHighAccel;

stNorth.sName := 'North';
stNorth.fPosition := fPosNorthBlade;
stNorth.fDelta := fSmallDelta;
stNorth.fVelocity := fMaxVelocity;
stNorth.fAccel := fHighAccel;
stNorth.fDecel := fHighAccel;

stSouth.sName := 'South';
stSouth.fPosition := fPosSouthBlade;
stSouth.fDelta := fSmallDelta;
stSouth.fVelocity := fMaxVelocity;
stSouth.fAccel := fHighAccel;
stSouth.fDecel := fHighAccel;

fbTop.bExecute := fbBottom.bExecute :=fbNorth.bExecute := fbSouth.bExecute := bExecuteMotion;

fbTop(
    stPositionState:=stTop,
    bMoveOk:=bMoveOk,
    stMotionStage:=stTopBlade);

fbBottom(
    stPositionState:=stBOTTOM,
    bMoveOk:=bMoveOk,
    stMotionStage:=stBottomBlade);

fbNorth(
    stPositionState:=stNorth,
    bMoveOk:=bMoveOk,
    stMotionStage:=stNorthBlade);

fbSouth(
    stPositionState:=stSouth,
    bMoveOk:=bMoveOk,
    stMotionStage:=stSouthBlade);


////RTDs
RTD_TOP_1();
RTD_TOP_2();
RTD_Bottom_1();
RTD_Bottom_2();
RTD_North_1();
RTD_North_2();
RTD_South_1();
RTD_South_2();

//Flow Switch
fbFlowSwitch();

END_FUNCTION_BLOCK
ACTION ACT_BLOCK:
rTrig_Block (CLK:= bBlock);
rTrig_Open (CLK:= bOpen);
rTrig_Close (CLK:= bClose);

if (rTrig_Block.Q) THEN
    //BLOCK

    bBlock := false;
END_IF

if (rTrig_Open.Q) THEN


    bOpen := false;
END_IF

if (rTrig_Close.Q) THEN


    bClose := false;
END_IF
END_ACTION
ACTION ACT_CalculatePositions:
//Calculate requested Positions


fPosTopBlade := (rReqApertureSizeY/2) + rReqCenterY;
fPosBottomBlade := (-1*rReqApertureSizeY/2) + rReqCenterY;

fPosNorthBlade := (rReqApertureSizeX/2) + rReqCenterX;
fPosSouthBlade := (-1*rReqApertureSizeX/2) + rReqCenterX;


//Calculate Actual Positions


rActApertureSizeX := ABS(stNorthBlade.stAxisStatus.fActPosition - stSouthBlade.stAxisStatus.fActPosition);

rActApertureSizeY := ABS(stTopBlade.stAxisStatus.fActPosition - stBottomBlade.stAxisStatus.fActPosition);

rActCenterX := ((stNorthBlade.stAxisStatus.fActPosition + stSouthBlade.stAxisStatus.fActPosition)/2);

rActCenterY := ((stTopBlade.stAxisStatus.fActPosition + stBottomBlade.stAxisStatus.fActPosition)/2);



//ZERO BIAS

// Set Y center to zero

// Set X center to zero
END_ACTION
```


POU: FB_XPIM
------------

File: Library/Devices/XPIM/FB_XPIM.TcPOU

```vhdl
FUNCTION_BLOCK FB_XPIM
VAR_IN_OUT
    stYStage: DUT_MotionStage;
    stZoomStage: DUT_MotionStage;
    stFocusStage: DUT_MotionStage;
    stEl6In: EL6inData22b;
    stEl6Out: EL6OutData22b;
END_VAR
VAR_INPUT
    bZoomEndFwd AT %I*: BOOL;
    bZoomEndBwd AT %I*: BOOL;
    bFocusEndFwd AT %I*: BOOL;
    bFocusEndBwd AT %I*: BOOL;

    fYag: LREAL;
    fDiamond: LREAL;
    fReticle: LREAL;
    fOut: LREAL;
END_VAR
VAR
    fbYStage: FB_MotionStage;
    fbZoom: FB_MotionStage;
    fbFocus: FB_MotionStage;

    {attribute 'pytmc' := '
        pv: MMS:STATE
        io: io
    '}
    fbStates: FB_XPIM_States;

    {attribute 'pytmc' := '
        pv: MFW
    '}
    fbFilterWheel: FB_XPIM_FilterWheel;

    {attribute 'pytmc' := '
        pv: CAM
    '}
    fbOpal: FB_XPIM_Opal;

    {attribute 'pytmc' := '
        pv: SFW
    '}
    fbFlowSwitch: FB_XTES_Flowswitch;
END_VAR
fbYStage(stMotionStage:=stYStage);
// All stages have no STO
stYStage.bHardwareEnable := TRUE;
stZoomStage.bHardwareEnable := TRUE;
stFocusStage.bHardwareEnable := TRUE;
// No PMPS yet
stYStage.bPowerSelf := TRUE;
stZoomStage.bPowerSelf := TRUE;
stFocusStage.bPowerSelf := TRUE;
// No limit switch at the bottom
stYStage.bLimitBackwardEnable := TRUE;
// Lens limits are normally open
stZoomStage.bLimitForwardEnable := NOT bZoomEndFwd;
stZoomStage.bLimitBackwardEnable := NOT bZoomEndBwd;
stFocusStage.bLimitForwardEnable := NOT bFocusEndFwd;
stFocusStage.bLimitBackwardEnable := NOT bFocusEndBwd;
// Home Lens to LLS
stZoomStage.nHomingMode := ENUM_EpicsHomeCmd.LOW_LIMIT;
stFocusStage.nHomingMode := ENUM_EpicsHomeCmd.LOW_LIMIT;
fbStates(
    stMotionStage:=stYStage,
    fYag:=fYag,
    fDiamond:=fDiamond,
    fReticle:=fReticle,
    fOut:=fOut);
fbZoom(stMotionStage:=stZoomStage);
fbFocus(stMotionStage:=stFocusStage);
fbFilterWheel(
    bExecute:=TRUE,
    stIn_El6:=stEl6In,
    stOut_El6:=stEl6Out);
fbOpal();
fbFlowSwitch();

END_FUNCTION_BLOCK
```


POU: FB_XPIM_FilterWheel
------------------------

File: Library/Devices/XPIM/FB_XPIM_FilterWheel.TcPOU

```vhdl
FUNCTION_BLOCK FB_XPIM_FilterWheel
VAR_INPUT
    bExecute: BOOL;

    {attribute 'pytmc' := '
        pv: ERR:RESET
        io: output
    '}
    bResetError: BOOL;

    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    nSetPos: ENUM_XPIM_Filters;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    nGetPos: ENUM_XPIM_Filters;
    bBusy: BOOL;
    bError: BOOL;
    sError: STRING;
    {attribute 'pytmc' := '
        pv: ERR:MSG
        io: input
    '}
    sLastError: STRING;
    sErrorTS: STRING;
END_VAR
VAR_IN_OUT
    stIn_EL6: EL6inData22B;
    stOut_EL6: EL6outData22B;
END_VAR
VAR
    {attribute 'pytmc' := '
        pv: RAW
    '}
    fbCom: FB_EL6_COM;

    nStep: USINT;
    sLastTestCmd: STRING;
    bIsTest: BOOL;
    fbGetTime: NT_GetTime;
    bStopOnErr: BOOL;
END_VAR
fbCom.sSendSuffix := '$R';
fbCom.sRecvSuffix := '$R';

IF bExecute AND nStep = 0 THEN
    IF bResetError OR NOT bError THEN
        nStep := 10;
    END_IF
ELSIF NOT bExecute THEN
    nStep := 0;
END_IF
CASE nStep OF
    0:
        ; // idle
    10:
        // Get position
        bIsTest := FALSE;
        fbCom(sCmd:='pos?',
            bSend:=TRUE,
            stIn_EL6:=stIn_EL6,
            stOut_EL6:=stOut_EL6);
        nStep := nStep + 10;
    20:
        // Wait for response and set variables
        fbCom(stIn_EL6:=stIn_EL6,
            stOut_EL6:=stOut_EL6);
        IF fbCom.bDone THEN
            bError := FALSE;
            sError := '';
            nGetPos := STRING_TO_USINT(fbCom.sResponse);
            nSetPos := nGetPos;
            nStep := nStep + 10;
            IF nGetPos = 0 THEN
                sError := 'Filter wheel in invalid state';
                bStopOnErr := TRUE;
                nStep := 50;
            END_IF
        END_IF
    30:
        // Wait for a move request
        IF nSetPos <> nGetPos THEN
            fbCom(sCmd:=CONCAT('pos=', INT_TO_STRING(nSetPos)),
                bSend:=TRUE,
                stIn_EL6:=stIn_EL6,
                stOut_EL6:=stOut_EL6);
            nStep := nStep + 10;
            bBusy := TRUE;
        END_IF
    40:
        fbCom(stIn_EL6:=stIn_EL6,
            stOut_EL6:=stOut_EL6);
        // Wait for move to be done
        IF fbCom.bDone THEN
            bBusy := FALSE;
            nStep := 10;
            // Handle setpoint error
            IF fbCom.sResponse = 'Command error CMD_ARG_INVALID$N$R' THEN
                sError := 'Invalid set position';
                nStep := 50;
            END_IF
        END_IF
    50:
        // Set sError and then jump here for standard handling
        sLastError := sError;
        bError := TRUE;
        fbGetTime(NETID:='',
            START:=TRUE);
        nStep := nStep + 10;
    60:
        // Error handling continued
        fbGetTime();
        IF NOT fbGetTime.BUSY THEN
            sErrorTS := SYSTEMTIME_TO_STRING(fbGetTime.TIMESTR);
            fbGetTime.START := FALSE;
            // set bStopOnErr to TRUE if it was a major error
            IF bStopOnErr THEN
                nStep := 0;
            ELSE
                nStep := 10;
            END_IF
            bStopOnErr := FALSE;
        END_IF
END_CASE
// Check for inner comms errors, report to EPICS same way
IF NOT bError AND
    (fbCom.eRecvErrorID <> COMERROR_NOERROR
    OR fbCom.eSendErrorID <> COMERROR_NOERROR
    OR fbCom.eRecvErrorID <> COMERROR_NOERROR) THEN
    sError := 'Serial Communication Error';
    bStopOnErr := TRUE;
    nStep := 50;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_XPIM_Opal
-----------------

File: Library/Devices/XPIM/FB_XPIM_Opal.TcPOU

```vhdl
FUNCTION_BLOCK FB_XPIM_Opal
VAR
    {attribute 'pytmc' := '
        pv: PWR
        io: io
        ZNAM: OFF
        ONAM: ON
    '}
    bOpalPower AT %Q*: BOOL;
    bOpalInit: BOOL := FALSE;

    {attribute 'pytmc' := '
        pv: CIL:PWR
        io: io
        ZNAM: OFF
        ONAM: ON
    '}
    bLedPower AT %Q*: BOOL;
END_VAR
// Turn the Opal on by default
IF NOT bOpalInit THEN
    bOpalPower := TRUE;
    bOpalInit := TRUE;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_XPIM_States
-------------------

File: Library/Devices/XPIM/FB_XPIM_States.TcPOU

```vhdl
FUNCTION_BLOCK FB_XPIM_States
VAR_IN_OUT
    stMotionStage: DUT_MotionStage;
END_VAR
VAR_INPUT
    bEnable: BOOL;
    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    enumSet: ENUM_XPIM_states;
    bStatesLock: BOOL;
    fOut: LREAL;
    fYag: LREAL;
    fDiamond: LREAL;
    fReticle: LREAL;
END_VAR
VAR_OUTPUT
    bError: BOOL;
    sErrorMessage: STRING;
    bBusy: BOOL;
    bDone: BOOL;
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    enumGet: ENUM_XPIM_States;
END_VAR
VAR
    bInit: BOOL;
    arrStates: ARRAY[1..15] OF DUT_PositionState;
    nIter: INT;

    {attribute 'pytmc' := '
        pv:
        io: io
    '}
    fbStateManager: FB_PositionStateManager;

    fbLockOut: FB_PositionStateLock;
    fbLockYag: FB_PositionStateLock;
    fbLockDiamond: FB_PositionStateLock;
    fbLockReticle: FB_PositionStateLock;
END_VAR
VAR CONSTANT
    fInDelta: LREAL := 0.1;
    fOutDelta: LREAL := 10;
    fInVelocity: LREAL := 20;
    fOutVelocity: LREAL := 20;
    fAccel: LREAL := 200;
    fOutDecel: LREAL := 25;
END_VAR
IF NOT bInit THEN
    bInit := FALSE;
    FOR nIter := 1 TO 4 DO
        arrStates[nIter].fDelta := fInDelta;
        arrStates[nIter].fVelocity := fInVelocity;
        arrStates[nIter].fAccel := fAccel;
        arrStates[nIter].fDecel := fAccel;
        arrStates[nIter].bLocked := bStatesLock;
        arrStates[nIter].bValid := TRUE;
        // TODO implement PMPS instead of doing this
        arrStates[nIter].bMoveOk := TRUE;
    END_FOR
    arrStates[1].sName := 'Out';
    arrStates[1].fPosition := fOut;
    arrStates[1].fDelta := fOutDelta;
    arrStates[1].fVelocity := fOutVelocity;
    arrStates[1].fDecel := fOutDecel;
    arrStates[2].sName := 'Yag';
    arrStates[2].fPosition := fYag;
    arrStates[3].sName := 'Diamond';
    arrStates[3].fPosition := fDiamond;
    arrStates[4].sName := 'Reticle';
    arrStates[4].fPosition := fReticle;
END_IF

fbLockOut(stPositionState := arrStates[1]);
fbLockYag(stPositionState := arrStates[2]);
fbLockDiamond(stPositionState := arrStates[3]);
fbLockReticle(stPositionState := arrStates[4]);

fbStateManager(
    stMotionStage := stMotionStage,
    arrStates := arrStates,
    setState := enumSet,
    bEnable := bEnable,
    bError => bError,
    sErrorMessage => sErrorMessage,
    bBusy => bBusy,
    bDone => bDone,
    getState => enumGet);

END_FUNCTION_BLOCK
```


POU: FB_XTES_Flowswitch
-----------------------

File: Library/POUs/FB_XTES_Flowswitch.TcPOU

```vhdl
FUNCTION_BLOCK FB_XTES_Flowswitch
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: FLOW
        ZNAM: LOW
        ONAM: OK
    '}
    bFlowOk AT %I*: BOOL;
END_VAR


END_FUNCTION_BLOCK
```


Symbols
-------


Boxes
-----

NC axes
-------

Links
-----


Pragma lint results
-------------------
```
INFO:pytmc.bin.pragmalint:Total pragmas found: 75 Total linter errors: 0
PLC Project (1): Library
========================


Devices/PPM/ENUM_PPM_States.TcDUT (TcPlcObject)
-----------------------------------------------

    - ENUM_PPM_States: Declaration - 1 pragmas


Devices/PPM/FB_PPM.TcPOU (TcPlcObject)
--------------------------------------

    - FB_PPM: Declaration - 5 pragmas


Devices/PPM/FB_PPM_Gige.TcPOU (TcPlcObject)
-------------------------------------------

    - FB_PPM_Gige: Declaration - 2 pragmas


Devices/PPM/FB_PPM_PowerMeter.TcPOU (TcPlcObject)
-------------------------------------------------

    - FB_PPM_PowerMeter: Declaration - 10 pragmas


Devices/PPM/FB_PPM_States.TcPOU (TcPlcObject)
---------------------------------------------

    - FB_PPM_States: Declaration - 3 pragmas


Devices/REF/FB_REF.TcPOU (TcPlcObject)
--------------------------------------

    - FB_REF: Declaration - 2 pragmas


Devices/REF/FB_REF_Laser.TcPOU (TcPlcObject)
--------------------------------------------

    - FB_REF_Laser: Declaration - 1 pragmas


Devices/SLITS/FB_SLITS_POWER.TcPOU (TcPlcObject)
------------------------------------------------

    - FB_SLITS_POWER: Declaration - 28 pragmas


Devices/XPIM/ENUM_XPIM_Filters.TcDUT (TcPlcObject)
--------------------------------------------------

    - ENUM_XPIM_Filters: Declaration - 1 pragmas


Devices/XPIM/ENUM_XPIM_States.TcDUT (TcPlcObject)
-------------------------------------------------

    - ENUM_XPIM_States: Declaration - 1 pragmas


Devices/XPIM/FB_XPIM.TcPOU (TcPlcObject)
----------------------------------------

    - FB_XPIM: Declaration - 4 pragmas


Devices/XPIM/FB_XPIM_FilterWheel.TcPOU (TcPlcObject)
----------------------------------------------------

    - FB_XPIM_FilterWheel: Declaration - 5 pragmas


Devices/XPIM/FB_XPIM_Opal.TcPOU (TcPlcObject)
---------------------------------------------

    - FB_XPIM_Opal: Declaration - 2 pragmas


Devices/XPIM/FB_XPIM_States.TcPOU (TcPlcObject)
-----------------------------------------------

    - FB_XPIM_States: Declaration - 3 pragmas


POUs/FB_L2SI_Flowmeter.TcPOU (TcPlcObject)
------------------------------------------

    - FB_L2SI_Flowmeter: Declaration - 2 pragmas


POUs/FB_XTES_Flowswitch.TcPOU (TcPlcObject)
-------------------------------------------

    - FB_XTES_Flowswitch: Declaration - 1 pragmas


Version/Global_Version.TcGVL (TcPlcObject)
------------------------------------------

    - Global_Version: Declaration - 4 pragmas

```
